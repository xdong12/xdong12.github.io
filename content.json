{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/09/30/hello-world/"},{"title":"为什么不能用可变对象作为默认参数的值","text":"先来看一道题目： 12345678910&gt;&gt;&gt; def func(numbers=[], num=1):... numbers.append(num)... return numbers&gt;&gt;&gt; func()[1]&gt;&gt;&gt; func()[1, 1]&gt;&gt;&gt; func()[1, 1, 1] 我们似乎发现了一个Bug，每次用相同的方式调用函数 func() 时，返回结果竟然不一样，而且每次返回的列表在不断地变长。 1234&gt;&gt;&gt; id(func())4330472840&gt;&gt;&gt; id(func())4330472840 从上面可以看出，函数的返回值其实是同一个列表对象，因为他们的id值是一样的，只不过是列表中的元素在变化。为什么会这样呢？ 这要从函数的特性说起，在 Python 中，**函数是第一类对象(function is the first class object)**，换而言之，函数也是对象，跟整数、字符串一样可以赋值给变量、当做参数传递、还可以作为返回值。函数也有自己的属性，比如函数的名字、函数的默认参数列表。 1234567# 函数的名字&gt;&gt;&gt; func.__name__ 'func'# 函数的默认参数列表&gt;&gt;&gt; func.__defaults__ ([1, 1, 1, 1, 1], 1) def是一条可执行语句，Python 解释器执行 def 语句时，就会在内存中就创建了一个函数对象（此时，函数里面的代码逻辑并不会执行，因为还没调用嘛），在全局命名空间，有一个函数名（变量叫 func）会指向该函数对象，记住，至始至终，不管该函数调用多少次，函数对象只有一个，就是function object，不会因为调用多次而出现多个函数对象。 函数对象生成之后，它的属性：名字和默认参数列表都将初始化完成。 初始化完成时，属性 __default__ 中的第一个默认参数 numbers 指向一个空列表。 当函数第一次被调用时，就是第一次执行 func()时，开始执行函数里面的逻辑代码（此时函数不再需要初始化了），代码逻辑就是往numbers中添加一个值为1的元素 第二次调用 func()，继续往numbers中添加一个元素 第三次、四次依此类推。 所以现在你应该明白为什么调用同一个函数，返回值确每次都不一样了吧。因为他们共享的是同一个列表(numbers)对象，只是每调用一次就往该列表中增加了一个元素 如果我们显示地指定 numbers 参数，结果截然不同。 12&gt;&gt;&gt; func(numbers=[10, 11])[10, 11, 1] 因为numbers被重新赋值了，它不再指向原来初始化时的那个列表了，而是指向了我们传递过去的那个新列表对象，因此返回值变成了 [10, 11, 1] 那么我们应该如何避免前面那种情况发生呢？就是不要用可变对象作为参数的默认值。 正确方式： 12345678910111213&gt;&gt;&gt; def func(numbers=None, num=1):... if numbers is None:... numbers = [num]... else:... numbers.append(num)... return numbers...&gt;&gt;&gt; func()[1]&gt;&gt;&gt; func()[1]&gt;&gt;&gt; func()[1] 如果调用时没有指定参数，那么调用方法时，默认参数 numbers 每次都被重新赋值了，所以，每次调用的时候numbers都将指向一个新的对象。这就是与前者的区别所在。 那么，是不是说我们永远都不应该用可变对象来作为参数的默认值了吗？并不是，既然Python有这样的语法，就一定有他的应用场景，就像 for … else 语法一样。我们可以用可变对象来做缓存功能。 例如：计算一个数的阶乘时可以用一个可变对象的字典当作缓存值来实现缓存，缓存中保存计算好的值，第二次调用的时候就无需重复计算，直接从缓存中拿。 123456789101112def factorial(num, cache={}): if num == 0: return 1 if num not in cache: print('xxx') cache[num] = factorial(num - 1) * num return cache[num]print(factorial(4))print(&quot;-------&quot;)print(factorial(4)) 输出： 12345678---第一次调用---xxxxxxxxxxxx24---第二次调用---24 第二次调用的时候，直接从 cache 中拿了值，所以，你说用可变对象作为默认值是 Python 的缺陷吗？也并不是，对吧！你还是当作一种特性来使用。","link":"/2020/10/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E7%94%A8%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E5%80%BC/"}],"tags":[],"categories":[]}